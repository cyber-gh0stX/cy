from __future__ import annotations
import os
import sys
import time
import json
import socket
import webbrowser
import platform
import subprocess
import threading
import http.server
import uuid
import shutil
from datetime import datetime

# ---------- Config ----------
DEV_NAME = "CYBER ALPHA"
TELEGRAM_LINK = "https://t.me/+qPkRrWEAblFkNTdk"
LOG_DIR = os.path.join(os.path.expanduser("~"), ".cyber_alpha")
JOIN_FLAG = os.path.join(os.path.expanduser("~"), ".cyber_alpha_joined")
API_URL_TEMPLATE = "http://ip-api.com/json/{ip}?fields=status,message,country,regionName,city,zip,lat,lon,timezone,isp,org,as,query,reverse,proxy,hosting"
# --------------------------------

# Colors only: white, green, red
try:
    from colorama import init as _colorama_init, Fore, Style
    _colorama_init(autoreset=True)
    WHITE = Fore.WHITE
    GREEN = Fore.GREEN
    RED = Fore.RED
    RESET = Style.RESET_ALL
except Exception:
    WHITE = "\033[97m"
    GREEN = "\033[92m"
    RED = "\033[91m"
    RESET = "\033[0m"

def tiny_pause():
    time.sleep(0.15)

def clear_screen():
    try:
        if os.name == "nt":
            os.system("cls")
        else:
            os.system("clear")
    except Exception:
        print("\n" * 80)

def ensure_log_dir():
    try:
        os.makedirs(LOG_DIR, exist_ok=True)
    except Exception:
        pass

def save_json(obj: dict, prefix="record"):
    ensure_log_dir()
    fn = f"{prefix}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    path = os.path.join(LOG_DIR, fn)
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(obj, f, indent=2, ensure_ascii=False)
        return path
    except Exception:
        return None

# ---------------- Telegram / Join flag ----------------
def is_joined_flag_set() -> bool:
    try:
        return os.path.exists(JOIN_FLAG)
    except Exception:
        return False

def set_joined_flag():
    try:
        with open(JOIN_FLAG, "w", encoding="utf-8") as f:
            f.write(f"joined:{datetime.now().isoformat()}\n")
    except Exception:
        pass

def clear_joined_flag():
    try:
        if os.path.exists(JOIN_FLAG):
            os.remove(JOIN_FLAG)
    except Exception:
        pass

def open_telegram_and_wait_if_needed():
    """Open telegram link and wait for user to press ENTER only if not previously joined."""
    if is_joined_flag_set():
        return
    try:
        webbrowser.open(TELEGRAM_LINK, new=2)
    except Exception:
        # fallback attempts
        try:
            system = platform.system().lower()
            if "darwin" in system:
                subprocess.Popen(["open", TELEGRAM_LINK])
            elif "linux" in system and shutil.which("xdg-open"):
                subprocess.Popen(["xdg-open", TELEGRAM_LINK])
            elif "windows" in system:
                try:
                    os.startfile(TELEGRAM_LINK)  # type: ignore[attr-defined]
                except Exception:
                    subprocess.Popen(["cmd", "/c", "start", "", TELEGRAM_LINK], shell=True)
        except Exception:
            pass
    print(WHITE + "A Telegram link was opened. Please join the channel, then press ENTER to continue." + RESET)
    try:
        input("> ")
        set_joined_flag()
    except KeyboardInterrupt:
        print("\n" + RED + "Interrupted. Exiting." + RESET)
        sys.exit(0)

# ---------------- trace ----------------
def fetch_geo(ip_or_domain: str, timeout: int = 10) -> dict:
    import urllib.request, urllib.error
    target = ip_or_domain
    url = API_URL_TEMPLATE.format(ip=target)
    req = urllib.request.Request(url, headers={"User-Agent": "Mozilla/5.0 (CYBERALPHA)"})
    try:
        with urllib.request.urlopen(req, timeout=timeout) as r:
            raw = r.read().decode("utf-8", errors="ignore")
            return json.loads(raw)
    except Exception as e:
        return {"status": "fail", "message": str(e)}

def run_traceroute_simple(target: str):
    system = platform.system().lower()
    if "windows" in system:
        prog = "tracert"
        args = [prog, "-d", target]
    else:
        if shutil.which("traceroute"):
            args = ["traceroute", "-n", "-w", "2", "-q", "1", target]
        elif shutil.which("tracepath"):
            args = ["tracepath", target]
        else:
            return False, "no traceroute/tracepath found"
    try:
        p = subprocess.run(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, timeout=120)
        return True, p.stdout
    except Exception as e:
        return False, str(e)

def cmd_trace():
    clear_screen()
    print(GREEN + f"CYBER ALPHA — trace ({DEV_NAME})" + RESET)
    try:
        ip = input(WHITE + "Enter IP or domain (or 'me'): " + RESET).strip()
    except KeyboardInterrupt:
        print("\n" + RED + "Interrupted. Returning to menu." + RESET)
        return
    if not ip:
        print(WHITE + "No target provided. Returning to menu." + RESET)
        return
    if ip.lower() in ("me", "myip", "my ip"):
        ip = ""
    geo = fetch_geo(ip)
    if geo.get("status") != "success":
        print(RED + "Lookup failed:" + RESET, WHITE + geo.get("message", "unknown") + RESET)
    else:
        print(GREEN + "IP:" + RESET, WHITE + geo.get("query", "N/A") + RESET)
        print(GREEN + "Country/Region:" + RESET, WHITE + f"{geo.get('country','N/A')} / {geo.get('regionName','N/A')}" + RESET)
        print(GREEN + "City/ZIP:" + RESET, WHITE + f"{geo.get('city','N/A')} / {geo.get('zip','N/A')}" + RESET)
        print(GREEN + "Coords:" + RESET, WHITE + f"{geo.get('lat','N/A')}, {geo.get('lon','N/A')}" + RESET)
        print(GREEN + "ISP/Org:" + RESET, WHITE + f"{geo.get('isp','N/A')} / {geo.get('org','N/A')}" + RESET)
    try:
        do_tr = input(WHITE + "Run traceroute? (y/N): " + RESET).strip().lower()
    except KeyboardInterrupt:
        print("\n" + RED + "Interrupted. Returning to menu." + RESET)
        return
    tr_output = None
    if do_tr == "y":
        print(WHITE + "Running traceroute..." + RESET)
        ok, out = run_traceroute_simple(geo.get("query") or ip)
        if ok:
            print(WHITE + out + RESET)
            tr_output = out
        else:
            print(RED + "Traceroute error:" + RESET, WHITE + out + RESET)
    rec = {"cmd":"trace","target":ip,"geo":geo,"traceroute": bool(tr_output), "traceroute_output": tr_output, "timestamp": datetime.now().isoformat()}
    p = save_json(rec, prefix="trace")
    if p:
        print(GREEN + f"Saved: {p}" + RESET)
    input(WHITE + "Press ENTER to return to menu." + RESET)

# ---------------- subhunt ----------------
DEFAULT_WORDS = [
    "www","mail","ftp","api","dev","staging","test","admin","portal","m","shop","cdn","smtp","webmail"
]
def resolve_name(name: str):
    try:
        return socket.gethostbyname(name)
    except Exception:
        return None

def cmd_subhunt():
    clear_screen()
    print(GREEN + "CYBER ALPHA — Subdomain Hunter (MVP)" + RESET)
    try:
        domain = input(WHITE + "Enter domain (example.com): " + RESET).strip()
    except KeyboardInterrupt:
        print("\n" + RED + "Interrupted. Returning to menu." + RESET)
        return
    if not domain:
        print(WHITE + "No domain given. Returning to menu." + RESET)
        return
    wordlist = DEFAULT_WORDS.copy()
    try:
        wl_path = input(WHITE + "Optional wordlist path (ENTER to skip): " + RESET).strip()
    except KeyboardInterrupt:
        print("\n" + RED + "Interrupted. Returning to menu." + RESET)
        return
    if wl_path:
        try:
            with open(wl_path, "r", encoding="utf-8") as f:
                extra = [l.strip() for l in f if l.strip()]
                wordlist = extra + wordlist
        except Exception as e:
            print(RED + "Could not read wordlist:" + RESET, WHITE + str(e) + RESET)
    found = []
    print(WHITE + f"Starting discovery on {domain} with {len(wordlist)} words..." + RESET)
    for w in wordlist:
        target = f"{w}.{domain}"
        ip = resolve_name(target)
        if ip:
            print(GREEN + f"[FOUND] {target} -> {ip}" + RESET)
            found.append({"host":target,"ip":ip})
        tiny_pause()
    outp = {"domain":domain,"found":found,"scanned":len(wordlist),"timestamp":datetime.now().isoformat()}
    path = save_json(outp, prefix="subhunt")
    print(GREEN + f"Done. Found {len(found)} hosts. Saved: {path}" + RESET)
    input(WHITE + "Press ENTER to return to menu." + RESET)

# ---------------- snapshot & diff ----------------
def gather_dns(domain: str):
    rec = {"domain":domain,"A":[]}
    try:
        try:
            ip = socket.gethostbyname(domain)
            rec["A"].append({"host":domain,"ip":ip})
        except Exception:
            pass
        try:
            ip2 = socket.gethostbyname("www."+domain)
            rec["A"].append({"host":"www."+domain,"ip":ip2})
        except Exception:
            pass
    except Exception:
        pass
    return rec

def cmd_snapshot():
    clear_screen()
    try:
        domain = input(WHITE + "Domain to snapshot: " + RESET).strip()
    except KeyboardInterrupt:
        print("\n" + RED + "Interrupted. Returning to menu." + RESET)
        return
    if not domain:
        print(WHITE + "No domain. Returning to menu." + RESET)
        return
    data = gather_dns(domain)
    data["timestamp"] = datetime.now().isoformat()
    path = save_json(data, prefix=f"snapshot_{domain.replace('.','_')}")
    print(GREEN + f"Snapshot saved: {path}" + RESET)
    input(WHITE + "Press ENTER to return to menu." + RESET)

def cmd_diff():
    clear_screen()
    try:
        a = input(WHITE + "First snapshot file path: " + RESET).strip()
        b = input(WHITE + "Second snapshot file path: " + RESET).strip()
    except KeyboardInterrupt:
        print("\n" + RED + "Interrupted. Returning to menu." + RESET)
        return
    if not a or not b:
        print(RED + "Provide both snapshot file paths. Returning to menu." + RESET)
        return
    try:
        with open(a, "r", encoding="utf-8") as fa:
            da = json.load(fa)
        with open(b, "r", encoding="utf-8") as fb:
            db = json.load(fb)
    except Exception as e:
        print(RED + "Could not load snapshots:" + RESET, WHITE + str(e) + RESET)
        input(WHITE + "Press ENTER to return to menu." + RESET)
        return
    a_hosts = {x["host"]: x["ip"] for x in da.get("A", [])}
    b_hosts = {x["host"]: x["ip"] for x in db.get("A", [])}
    added = [h for h in b_hosts if h not in a_hosts]
    removed = [h for h in a_hosts if h not in b_hosts]
    changed = [h for h in b_hosts if h in a_hosts and a_hosts[h] != b_hosts[h]]
    print(GREEN + "Snapshot Diff Result" + RESET)
    print(WHITE + f"Added hosts: {added}" + RESET)
    print(WHITE + f"Removed hosts: {removed}" + RESET)
    print(WHITE + f"Changed IPs: {changed}" + RESET)
    input(WHITE + "Press ENTER to return to menu." + RESET)

# ---------------- canary ----------------
class SimpleCanaryHandler(http.server.BaseHTTPRequestHandler):
    server_version = "CYBERALPHACANARY/1.0"
    def do_GET(self):
        try:
            path = self.path
            hdrs = dict(self.headers)
            record = {
                "timestamp": datetime.now().isoformat(),
                "path": path,
                "headers": hdrs,
                "client": self.client_address
            }
            ensure_log_dir()
            fn = os.path.join(LOG_DIR, "canary_hits.log")
            with open(fn, "a", encoding="utf-8") as f:
                f.write(json.dumps(record, ensure_ascii=False) + "\n")
            self.send_response(200)
            self.send_header("Content-Type","text/plain; charset=utf-8")
            self.end_headers()
            self.wfile.write(b"OK")
        except Exception:
            self.send_response(500)
            self.end_headers()
    def log_message(self, format, *args):
        return

def cmd_canary():
    clear_screen()
    print(GREEN + "CYBER ALPHA — Local Canary" + RESET)
    try:
        port_raw = input(WHITE + "Port to listen on (default 8080): " + RESET).strip()
    except KeyboardInterrupt:
        print("\n" + RED + "Interrupted. Returning to menu." + RESET)
        return
    port = int(port_raw) if port_raw.isdigit() else 8080
    token = uuid.uuid4().hex
    url = f"http://{socket.gethostbyname(socket.gethostname()) if socket.gethostname() else 'localhost'}:{port}/{token}"
    print(WHITE + f"Local canary URL: {url}" + RESET)
    print(WHITE + "To expose externally use ngrok or port forwarding." + RESET)
    try:
        server = http.server.HTTPServer(("0.0.0.0", port), SimpleCanaryHandler)
    except Exception as e:
        print(RED + "Failed to start listener:" + RESET, WHITE + str(e) + RESET)
        input(WHITE + "Press ENTER to return to menu." + RESET)
        return
    t = threading.Thread(target=server.serve_forever, daemon=True)
    t.start()
    print(GREEN + f"Listener started on port {port}. Hits will be logged to: {os.path.join(LOG_DIR,'canary_hits.log')}" + RESET)
    try:
        input(WHITE + "Press ENTER to stop the listener and return to menu." + RESET)
    except KeyboardInterrupt:
        pass
    server.shutdown()
    server.server_close()
    print(GREEN + "Listener stopped." + RESET)
    input(WHITE + "Press ENTER to return to menu." + RESET)

# ---------------- credmap ----------------
SAMPLE_PUBLIC_LEAKS = [
    "admin@example.com",
    "john.doe@example.net",
    "alice@example.org"
]
def cmd_credmap():
    clear_screen()
    print(GREEN + "CYBER ALPHA — Credential Mapper (MVP)" + RESET)
    try:
        raw = input(WHITE + "Enter comma-separated usernames or emails: " + RESET).strip()
    except KeyboardInterrupt:
        print("\n" + RED + "Interrupted. Returning to menu." + RESET)
        return
    names = [x.strip() for x in raw.split(",") if x.strip()]
    if not names:
        print(WHITE + "No usernames provided. Returning to menu." + RESET)
        return
    results = []
    for n in names:
        score = 0
        reasons = []
        low = n.lower()
        if any(low in s.lower() for s in SAMPLE_PUBLIC_LEAKS):
            score += 80
            reasons.append("Exact match found in sample leaks")
        if "@" in n:
            score += 10
            reasons.append("Email format (higher exposure risk)")
        if len(n) <= 4:
            score += 5
            reasons.append("Short username")
        results.append({"username": n, "score": score, "reasons": reasons})
    print(WHITE + json.dumps(results, indent=2, ensure_ascii=False) + RESET)
    p = save_json({"cmd":"credmap","input":names,"results":results}, prefix="credmap")
    if p:
        print(GREEN + f"Saved: {p}" + RESET)
    input(WHITE + "Press ENTER to return to menu." + RESET)

# ---------------- menu ----------------
def print_header():
    clear_screen()
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(GREEN + f"CYBER ALPHA — {DEV_NAME}".ljust(80) + RESET)
    print(WHITE + f"Started: {now}".ljust(80) + RESET)
    print("-" * 80)
    print(WHITE + "All actions are for authorized testing only. Use responsibly." + RESET)
    print("-" * 80)

def menu_loop():
    # open telegram join on first run if not joined
    open_telegram_and_wait_if_needed()
    while True:
        print_header()
        print(WHITE + "Select an option:" + RESET)
        print(WHITE + " 1) Trace (IP geolocation + traceroute)" + RESET)
        print(WHITE + " 2) Subhunt (subdomain discovery)" + RESET)
        print(WHITE + " 3) Perimeter snapshot (save DNS info)" + RESET)
        print(WHITE + " 4) Perimeter diff (compare snapshots)" + RESET)
        print(WHITE + " 5) Canary (local HTTP listener)" + RESET)
        print(WHITE + " 6) Credmap (username exposure heuristics)" + RESET)
        print(WHITE + " 7) Toggle Telegram join flag (mark joined / unmark)" + RESET)
        print(WHITE + " 0) Exit" + RESET)
        try:
            choice = input(WHITE + "Choice: " + RESET).strip()
        except KeyboardInterrupt:
            print("\n" + RED + "Keyboard interrupt. Exiting." + RESET)
            return
        if choice == "1":
            try:
                cmd_trace()
            except Exception as e:
                print(RED + "Error in trace:" + RESET, WHITE + str(e) + RESET)
                input(WHITE + "Press ENTER to return to menu." + RESET)
        elif choice == "2":
            try:
                cmd_subhunt()
            except Exception as e:
                print(RED + "Error in subhunt:" + RESET, WHITE + str(e) + RESET)
                input(WHITE + "Press ENTER to return to menu." + RESET)
        elif choice == "3":
            try:
                cmd_snapshot()
            except Exception as e:
                print(RED + "Error in snapshot:" + RESET, WHITE + str(e) + RESET)
                input(WHITE + "Press ENTER to return to menu." + RESET)
        elif choice == "4":
            try:
                cmd_diff()
            except Exception as e:
                print(RED + "Error in diff:" + RESET, WHITE + str(e) + RESET)
                input(WHITE + "Press ENTER to return to menu." + RESET)
        elif choice == "5":
            try:
                cmd_canary()
            except Exception as e:
                print(RED + "Error in canary:" + RESET, WHITE + str(e) + RESET)
                input(WHITE + "Press ENTER to return to menu." + RESET)
        elif choice == "6":
            try:
                cmd_credmap()
            except Exception as e:
                print(RED + "Error in credmap:" + RESET, WHITE + str(e) + RESET)
                input(WHITE + "Press ENTER to return to menu." + RESET)
        elif choice == "7":
            # toggle join flag
            if is_joined_flag_set():
                clear_joined_flag()
                print(WHITE + "Join flag cleared. Next run will prompt to join Telegram." + RESET)
            else:
                set_joined_flag()
                print(WHITE + "Join flag set. Next runs will not prompt to join Telegram." + RESET)
            input(WHITE + "Press ENTER to return to menu." + RESET)
        elif choice == "0":
            print(WHITE + "Goodbye — stay safe." + RESET)
            return
        else:
            print(RED + "Invalid choice. Try again." + RESET)
            tiny_pause()

if __name__ == "__main__":
    try:
        ensure_log_dir()
        menu_loop()
    except KeyboardInterrupt:
        print("\n" + RED + "Keyboard interrupt. Exiting." + RESET)
        try:
            sys.exit(0)
        except SystemExit:
            os._exit(0)
